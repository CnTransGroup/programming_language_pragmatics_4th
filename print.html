<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>编程语言语用论（第4版）</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreward.html">Foreword</a></li><li class="chapter-item expanded "><a href="part1.foundations.html">Part I: Foundations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1.introduction.html">Chapter 1: Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1.1.the_art_of_language_design.html">1.1 The Art of Language Design</a></li><li class="chapter-item "><a href="1.2.the_programming_language_spectrum.html">1.2 The Programming Language Spectrum</a></li><li class="chapter-item "><a href="1.3.why_study_programming_language.html">1.3 Why Study Programming Languages?</a></li></ol></li><li class="chapter-item "><a href="2.programming_language_syntax.html">Chapter 2: Programming Language Syntax</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2.1.specifying_syntax.html">2.1 Specifying Syntax: Regular Expressions and Context-Free Grammars</a></li><li class="chapter-item "><a href="2.2.scanning.html">2.2 Scanning</a></li><li class="chapter-item "><a href="2.3.parsing.html">2.3 Parsing</a></li><li class="chapter-item "><a href="2.4.theoretical_foundations.html">2.4 Theoretical Foundations</a></li></ol></li><li class="chapter-item "><a href="3.names_scopes_bindings.html">Chapter 3: Names, Scopes, and Bindings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="3.1.the_notion_of_binding_time.html">3.1 The Notion of Binding Time</a></li><li class="chapter-item "><a href="3.2.object_lifetimes_and_storage_management.html">3.2 Object Lifetimes and Storage Management</a></li><li class="chapter-item "><a href="3.3.scope_rules.html">3.3 Scope Rules</a></li><li class="chapter-item "><a href="3.4.implementing_scope.html">3.4 Implementing Scope</a></li><li class="chapter-item "><a href="3.5.the_meaning_of_names_within_a_scope.html">3.5 The Meaning of Names within a Scope</a></li><li class="chapter-item "><a href="3.6.the_binding_of_referencing_environments.html">3.6 The Binding of Referencing Environments</a></li><li class="chapter-item "><a href="3.7.macro_expansion.html">3.7 Macro Expansion</a></li><li class="chapter-item "><a href="3.8.separate_compilation.html">3.8 Separate Compilation</a></li></ol></li><li class="chapter-item "><a href="4.semantic_analysis.html">Chapter 4: Semantic Analysis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="4.1.the_role_of_the_semantic_analyzer.html">4.1 The Role of The Semantic Analyzer</a></li><li class="chapter-item "><a href="4.2.attribute_grammar.html">4.2 Attribute Grammar</a></li><li class="chapter-item "><a href="4.3.evaluating_attributes.html">4.3 Evaluating Attributes</a></li><li class="chapter-item "><a href="4.4.action_routines.html">4.4 Action Routines</a></li><li class="chapter-item "><a href="4.5.space_management_for_attributes.html">4.5 Space Management for Attributes</a></li><li class="chapter-item "><a href="4.6.tree_grammars_and_syntax_tree_decoration.html">4.6 Tree Grammars and Syntax Tree Decoration</a></li></ol></li><li class="chapter-item "><a href="5.target_machine_architecture.html">Chapter 5: Target Machine Architecture</a></li></ol></li><li class="chapter-item expanded "><a href="part2.core_issues_in_language_design.html">Part II: Core Issues in Language Design</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="6.control_flow.html">Chapter 6: Control Flow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="6.1.expression_evaluation.html">6.1 Expression evaluation</a></li><li class="chapter-item "><a href="6.2.structured_and_unstructured_flow.html">6.2 Structured and Unstructured Flow</a></li><li class="chapter-item "><a href="6.3.sequencing.html">6.3 Sequencing</a></li><li class="chapter-item "><a href="6.4.selection.html">6.4 Selection</a></li><li class="chapter-item "><a href="6.5.iteration.html">6.5 Iteration</a></li><li class="chapter-item "><a href="6.6.recursion.html">6.6 Recursion</a></li><li class="chapter-item "><a href="6.7.nondeterminacy.html">6.7 Nondeterminacy</a></li></ol></li><li class="chapter-item "><a href="7.type_systems.html">Chapter 7: Type Systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="7.1.overview.html">7.1 Overview</a></li><li class="chapter-item "><a href="7.2.type_checking.html">7.2 Type Checking</a></li><li class="chapter-item "><a href="7.3.parametric_polymorphism.html">7.3 Parametric Polymorphism</a></li><li class="chapter-item "><a href="7.4.equality_tesing_and_assignment.html">7.4 Equality Tesing and Assignment</a></li></ol></li><li class="chapter-item "><a href="8.composite_types.html">Chapter 8: Composite Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="8.1.records_structures.html">8.1 Records(Structures)</a></li><li class="chapter-item "><a href="8.2.arrays.html">8.2 Arrays</a></li><li class="chapter-item "><a href="8.3.strings.html">8.3 Strings</a></li><li class="chapter-item "><a href="8.4.sets.html">8.4 Sets</a></li><li class="chapter-item "><a href="8.5.pointers_and_recursive_types.html">8.5 Pointers and Recursive Types</a></li><li class="chapter-item "><a href="8.6.lists.html">8.6 Lists</a></li><li class="chapter-item "><a href="8.7.files_and_input_output.html">8.7 Files and Input/Output</a></li></ol></li><li class="chapter-item "><a href="9.subroutines_and_control_abstraction.html">Chapter 9: Subroutines and Control Abstraction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="9.1.review_of_stack_layout.html">9.1 Review of Stack Layout</a></li><li class="chapter-item "><a href="9.2.calling_sequences.html">9.2 Calling Sequences</a></li><li class="chapter-item "><a href="9.4.exception_handling.html">9.3 Parameter Passing</a></li><li class="chapter-item "><a href="9.5.coroutines.html">9.5 Coroutines</a></li><li class="chapter-item "><a href="9.6.events.html">9.6 Events</a></li></ol></li><li class="chapter-item "><a href="10.data_abstraction_and_object_orientation.html">Chapter 10: Data Abstraction and Object Orientation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="10.1.object_oriented_programming.html">10.1 Object-Oriented Programming</a></li><li class="chapter-item "><a href="10.2.encapsulation_and_inheritance.html">10.2 Encapsulation and Inheritance</a></li><li class="chapter-item "><a href="10.3.initialization_and_finalization.html">10.3 Initialization and Finalization</a></li><li class="chapter-item "><a href="10.4.dynamic_method_binding.html">10.4 Dynamic method Binding</a></li><li class="chapter-item "><a href="10.5.mix_in_inheritance.html">10.5 Mix in Inheritance</a></li><li class="chapter-item "><a href="10.6.true_multiple_inheritance.html">10.6 True Multiple Inheritance</a></li><li class="chapter-item "><a href="10.7.object_oriented_programming_revisited.html">10.7 Object-Oriented Progamming Revisited</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="part3.alternative_programming_models.html">Part III: Alternative Programming Models</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="11.functional_languages.html">Chapter 11: Functional Languages</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="11.1.historical_origins.html">11.1 Historical Origins</a></li><li class="chapter-item "><a href="11.2.functional_programming_concepts.html">11.2 Functional Programming Concepts</a></li><li class="chapter-item "><a href="11.3.a_bit_of_scheme.html">11.3 a Bit of Scheme</a></li><li class="chapter-item "><a href="11.4.a_bit_of_ocaml.html">11.4 a Bit of Ocaml</a></li><li class="chapter-item "><a href="11.5.evaluation_order_revisited.html">11.5 Evaluation Order Revisited</a></li><li class="chapter-item "><a href="11.6.higher_order_functions.html">11.6 Higher Order Functions</a></li><li class="chapter-item "><a href="11.7.theoretical_foundations.html">11.7 Theoretical Foundations</a></li><li class="chapter-item "><a href="11.8.functional_programming_in_perspective.html">11.8 Functional Programming in Perspective</a></li></ol></li><li class="chapter-item "><a href="12.logic_languages.html">Chapter 12: Logic Languages</a></li><li class="chapter-item "><a href="13.concurrency.html">Chapter 13: Concurrency</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="13.1.background_and_motivation.html">13.1 Background and Motivation</a></li><li class="chapter-item "><a href="13.2.concurrent_programming_fundamentals.html">13.2 Concurrent Programming Fundamentals</a></li><li class="chapter-item "><a href="13.3.implementing_synchronization.html">13.3 Implementing Synchronization</a></li><li class="chapter-item "><a href="13.4.language_level_constructs.html">13.4 Language Level Constructs</a></li><li class="chapter-item "><a href="13.5.message_passing.html">13.5 Message Passing</a></li></ol></li><li class="chapter-item "><a href="14.scripting_languages.html">Chapter 14: Scripting Languages</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="14.1.what_is_a_scripting_language.html">14.1 What is a Scripting Language</a></li><li class="chapter-item "><a href="14.2.problem_domains.html">14.2 Problem Domains</a></li><li class="chapter-item "><a href="14.3.scriping_the_world_wide_web.html">14.3 Scripting the World Wide Web</a></li><li class="chapter-item "><a href="14.4.innovative_features.html">14.4 Innovative Features</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="part4.closer_look_at_implementation.html">Part IV: A Closer Look at Implementation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="15.building_a_runnable_program.html">Chapter 15: Building a Runnalble Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="15.1.back_end_compiler_structure.html">15.1 Back-end Compiler Structure</a></li><li class="chapter-item "><a href="15.2.intermediate_forms.html">15.2 Intermediate Forms</a></li><li class="chapter-item "><a href="15.3.code_generation.html">15.3 Code Generation</a></li><li class="chapter-item "><a href="15.4.address_space_organization.html">15.4 Address Space Organization</a></li><li class="chapter-item "><a href="15.5.assembly.html">15.5 Assembly</a></li><li class="chapter-item "><a href="15.6.linking.html">15.6 Linking</a></li><li class="chapter-item "><a href="15.7.dynamic_linking.html">15.7 Dynamic Linking</a></li></ol></li><li class="chapter-item "><a href="16.run-time_program_management.html">Chapter 16: Run-Time Program Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="16.1.virtual_machine.html">16.1 Virtual Machine</a></li><li class="chapter-item "><a href="16.2.late_binding_of_machine_code.html">16.2 Late Binding of Machine Code</a></li><li class="chapter-item "><a href="16.3.inspection_or_introspection.html">16.3 Inspection/Introspection</a></li></ol></li><li class="chapter-item "><a href="17.code_improvement.html">Chapter 17: Code Improvement</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">编程语言语用论（第4版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CnTransGroup/programming_language_pragmatics_4th" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>编程语言被认为计算机科学家必须掌握的一个核心课程。原因很明显：编程语言是我们用于开发新产品和交流新想法的载体。他们通过数百万行的代码描述该领域的问题并施加影响。他们的成功归功于计算机科学界在创建新语言和实施方面的长期努力。</p>
<p>已经有超过 75 种编程语言被讨论。它们代表了过去数十年在语言设计领域最好和最具影响力的贡献。最开始是 1950 年代的 Fortran 和 Lisp，随后又出现了多种语言，以及用于动态编程的 Web 语言。75 种语言中包含的范式有命令性，函数式，逻辑性，静态，动态，序列，共享内存并发，分布内存并发，数据流，high-level 和交互式语言。同时包括了不同的领域，科学计算，符号操作，数据库访问等。语言的多样性对于程序员的生产力是很重要的，并且这些也是计算机学科重要的资产。</p>
<p>本书介绍了流程控制，类型和抽象机制。这些是开发出组织良好，模块化，易于理解，易于维护程序的必要表征。对于当今语言这些核心特性的理解是成为更好的开发者以及更好理解计算机科学的基本前提。</p>
<p>必须与设计范式一起研究实现编程语言的策略。原因是一门语言的成功取决于实现的质量。同样，策略的选择会限制语言的设计。语言的实现开始于解析（parsing）和词法扫描（lexical scanning）来计算出程序的句法（syntactic）结构。今天的解析技术，在 Part I 中讨论，是有史以来最优雅的算法之一，是使用数学对象创建实用工具的例子之一。仅仅作为智力成果就值得学习。当然它们具有巨大的实用价值，也是欣赏这些实现第一版 Fortran 编译器中使用的伟大策略的一个好途径。</p>
<p>实现的另一个组成部分是将 high-level 语言转换成适用机器执行语言的编译器组件。这种转换可以率先完成（静态语言），也可以执行期间完成（动态语言），也可以兼而有之。本书讨论了包括通过解析驱动的转换的优雅机制的方法和实现。为了生成高效代码，转换策略避免冗余计算，高效利用内存的层次，并且利用处理器的并发能力。这些有时候矛盾的目标被编译器的优化组件接管。尽管这些内容并不应该包括在编译器的第一课中，本书还是在第四部分（Part IV）给出了不错的概述。</p>
<p>计算近期最重要的发展是并发能力的普及和利用，在可预期的将来，利用并发性将带来性能提升。本书通过向读者展示并发编程的一系列主题来回应这一发展，包括跨线程同步，通信和线程间协调。这些信息随着并行计算的普及变得越来越重要。</p>
<p>编程语言是开发者和机器之间的桥梁。算法必须表现为可执行文件。编程语言设计的学习和实现将给你一个很好的对于连接计算策略理解。通过对该主题广泛的表述， Michael Scott 的这本书，是对编程语言学的巨大贡献。</p>
<hr />
<p><a href="https://booksite.elsevier.com/9780124104099/">本书的网站</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>编程语言实用主义的主要前提的语言设计和实现是紧密相关的，分离开是难以学习的。</p>
<p>Part II 和 Part III 的组织是围绕语言设计的，但是很多问题是通过实现来描述。</p>
<p>第一部分覆盖了设计和实现的基本概念。第一章激发编程语言学习的热情，介绍了主流语言家族，提供了编译过程的概述。第三章覆盖了高层次语言结构，重点是 names, binding of names to objects, 和 scope rules。在这个过程中涉及到了存储管理，subroutines，模块，类，多态和分离编译。</p>
<p>第2，4，5章更侧重实现。它们提供了 Part II 和 Part III 提到的背景和实现问题。第二章讨论程序的语法（句法 syntax），文本结构。介绍了正则表达式和上下文无关语法，设计师用来描述程序语法，并结合编译器或者解释器的扫描和解析算法来识别句法。给定了对于句法的理解，第4章解释编译器（或解释器）如何确定程序的语义。这个讨论围绕属性语法概念进行，用来将程序映射成具有意义的内容，比如数学或者其他存在的语言。最后，第5章（完全站在同伴的角度）提供了汇编级别计算的架构，重点介绍了与编译器最相关的现代微处理器的特性。理解这些的开发者不仅会对语言为什么这样设计有更好的理解，而且可以充分利用语言。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>第一台电子计算机非常巨大，占满了几件屋子，耗电巨大，花费了1940年代的巨款（但是计算性能也就现在的手机水平）。使用这种机器的编程人员认为机器的时间比人的更有价值，他们使用机器语言进行编程。机器语言就是比特序列，可以直接控制处理器在适当时间进行加法，比较，移动数据。这种程序的编写是一项无聊且庞大的任务。下面这段程序计算使用欧几里得算法两个整数的公共除数（GCD）。使用机器语言编写，通过16进制数表达的，可以运行在x86指令集处理器。</p>
<p><img src="./assets/1.introduction/image-20220708162408395.png" alt="image-20220708162408395" /></p>
<p>当人们开始编写大型程序时，显然需要更不易出错的符号集。于是使用容易记忆的缩写的符号的汇编语言被发明。使用汇编编写 GCD 程序如下图：</p>
<p><img src="./assets/1.introduction/image-20220708162432174.png" alt="image-20220708162432174" /></p>
<p>汇编语言最初被设计为机器指令与方便记忆缩写一对一。将缩写翻译成机器指令的系统程序被称为汇编器（assembler）。Assembler 通过宏扩展的能力允许开发者为常见指令定义参数化的缩写。但是汇编语言和机器语言的关系仍然很明确。编程仍然是以机器为中心：每种不同的计算机有自己的汇编语言，编程人员必须以计算机的方式思考。</p>
<p>随着计算机的进步以及竞争设计的发展，必须为每种新的计算机重写程序让人沮丧。人们也越来越难以记忆汇编语言的大量细节。人们开始希望有一种机器无关的语言，其中数值计算（当时最常见的程序）可以使用类似数学公司的表达。这直接推动了 1950 年代第一门高级语言 Fortran 语言的诞生，随后 Lisp 和 Algo 也随即出现。</p>
<p>将高级语言转换成汇编或者机器码是编译器（compiler）的工作。compiler 比 assembler 要复杂的多，因为不存在源文件到机器指令的一对一关系。Fortran 开始很慢，因为人类总是可以付出一定的努力写出对应的汇编程序，这些程序的运行速度要比 compiler 产生的快。但是随着时间流逝，性能的差距在变小，甚至 compiler 产生的程序更快。由于硬件复杂性的提升（pipeline, multiple functional units 等）和 compiler 技术的改进，compiler 通常会生成比人类写的更好的代码。即使有些场景人类写的更快，机器性能的提升以及程序规模的增大使得这种努力微不足道，因为程序不仅仅写出来就完成工作，还包括了后续的维护，修复和改进，现在人工的成本早就超过了计算机本身。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="语言设计的现状"><a class="header" href="#语言设计的现状">语言设计的现状</a></h2>
<p>今天有成千上百种编程语言，而且新语言还在不断被发明。为什么需要这么多？有几个可能的回答：</p>
<ul>
<li>Evolution</li>
<li>Special Purposes</li>
<li>Personal Preference</li>
<li>Expressive Power</li>
<li>Ease of Use for the Novice</li>
<li>Ease of Implementation</li>
<li>Standardization</li>
<li>Open Source</li>
<li>Excellent Compilers（优秀的编译器）。Fortran 的成功归功于优秀的编译器。在某种程度上这是历史问题。Fortran 已经存在了太久，公司已经花费了太多的时间和金钱使得编译器生成性能很高的代码。但是这也是语言设计的问题，在90年代之前 Fortran 没有递归和指针，这些功能会影响代码生成（起码对于不需要这些功能的程序）。同样某些语言，比如 Lisp 的成功，部分原因就是它们具有编译器以及具有帮助编程人员管理大型程序的工具。</li>
<li>Economics, Patronage, and Inertia（经济学，资助和惯性）。最后，除了技术有点之外，其他因素极大影响了成功。强大的赞助商就是一个因素。PL/I 首先归功于 IBM，Cobol 和 Ada 归功于美国国防部，C# 归功于微软。近些年，Object-C 作为 iPhone 和 iPad 的官方语言也越来越流行。生命周期的另一环在于，即使有了更好的替代品，但是已经有了太多的遗留设施，替换的成本太高，比如世界金融基础设施还有很多 Cobol 发挥着作用。</li>
</ul>
<p>清楚的看到没有单一因素决定一门语言是不是够好。同样在学习语言的过程中，我们也要从几个角度来考虑问题。尤其是，我们应该考虑程序员和语言实现者的观点。有时候这些观点比较统一的，比如对于执行速度的追求。然而，通常情况下存在冲突和权衡，比如新功能的实现和成本之间的权衡。功能的实现提升的成本不只是使用这个功能的程序，还有不使用这种功能的程序。</p>
<p>在早期，实现语言者的观点是主要的。编程语言演变为告诉计算机怎么做的一种手段。对于开发者，语言更像是表达算法的一种手段。就像自然语言约束了观点的表达与论述，编程语言也约束了容易和不容易表达的内容，同时也对程序员的想法具有深远微妙的影响。Donald Knuth 将编程视作一种告诉其他人计算机如何工作的艺术。这个定义也许是最好的，它承认概念的清晰和实现效率都是基本问题。本书试图抓住折中的精神，考虑每个主题的概念和实现两方面内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编程语言范围"><a class="header" href="#编程语言范围">编程语言范围</a></h2>
<p>很多现存的语言可以根据计算模型分类。下图展示了一些公共的家族。第一级按照声明式还是命令式分开，声明式表示计算机做什么，命令式表示计算机如何做。</p>
<p><img src="assets/1.2.the_programming_language_spectrum/image-20220709101621852.png" alt="image-20220709101621852" /></p>
<p>声明式语言某种程度上来说是“更高级别”的语言；它们更符合程序员的观点，而不是实现者观点。但是出于性能问题，命令式语言才是主流。在避免“无关”的实现细节的愿望与尽可能控制算法细节之间声明式语言可以保持张力。毕竟计算机科学的大部分内容是高效算法的设计。我们实际并不清楚对于什么内容，什么问题范围，对于 compiler 需要在高层次问题抽象上发现良好算法。对于 compiler 不能发挥最用的问题领域，开发者需要定制一个。</p>
<p>在声明和命令式家族之下，还有一些子家族：</p>
<ul>
<li>函数式语言采用机遇函数递归定义的计算模型。由 1930 年代的 lambda calculus 演算启发。程序本质上被视作映射输入到输出的函数，这个函数是通过过程定义。本类别的语言有 Lisp, ML, Haskell.</li>
<li>数据流语言计算模型是信息在处理节点的信息流动。天然就是并行的：节点被输入触发，然后并行执行。Id Val 是数据流语言。Sisal 是 Val 的后继者，更多的被看作函数式语言。</li>
<li>Logic or constraint-based 语言从谓词中得到灵感。计算模型是通过目标定向的逻辑规则列表来查找满足某些关系的值。Prolog 是最知名的 logic 语言。这个术语有时候也用于 SQL 数据库语言，XSLT 脚本语言，Excel 编程语言。</li>
<li>von Neumann 语言（冯 诺伊曼语言）可能是最广泛的语言。包括 Fortran， Ada， C 以及所有通过变量修饰的语言。不同于函数式语言基于 expressions ，冯诺伊曼语言基于 statements，通过改变内存的值来影响一系列计算序列。</li>
<li>面向对象语言来源于 Simula 67.更接近冯诺伊曼语言，但是内存和计算更结构化。并没有将计算看作在处理器上的操作，而是抽象为对象之间的交互，每个对象有自身的内部状态和子例程管理状态。Smalltak 是最纯碎的面向对象的语言；C++ 和 Java 应用最广泛。也可以设计面向对象的函数式语言（最知名的是 CLOS 和 OCaml），但是通常它们具有强烈的命令式味道。</li>
<li>脚本语言强调“粘合在一起”功能。脚本语言最初因为特定目的被发明出来：csh 和 bash 作为 job control 从 shell； PHP 和 JS 生产动态 web 内容；Lua 用于控制计算机游戏。其他语言，包括Perl，Python，Ruby 更通用。大多数原型开发更偏向开发速度而不是执行速度。</li>
</ul>
<p>可能会疑问并发语言为什么没有单独分一个家族（事实上本书有一章专门讨论这个话题），但是并行还是顺序执行跟上面的分类是无关的。大多数并发程序是使用库或 compiler 联合顺序语言比如 Fortran 或 C 编写的。一些广泛应用的语言，比如 Java，C#， Ada 具有显式的并发特性。研究人员正在研究每种语言的并发能力。</p>
<p>作为语言家族对比的简单例子，考虑 GCD 问题。冯诺伊曼语言，函数式，logic 语言对于这个问题的表达不仅影响了代码表示，还影响了程序猿的思想。冯诺伊曼语言的算法版本完全是命令式：</p>
<blockquote>
<p>计算 a 和 b 的 gcd，检查 a 和 b 是否相等。如果相等，打印其中一个，停止。否则选择较大的和差值重复上面的过程。</p>
</blockquote>
<p>C 代码如下:</p>
<pre><code class="language-c">// c code
int gcd(int a, int b) {
  while(a != b) {
    if (a &gt; b) a = a - b;
    else b = b - a;
  }
  return a;
}
</code></pre>
<p>函数式语言，重点是输出到输入的数学关系：</p>
<blockquote>
<p>a 和 b 的 gcd 定义为：</p>
<ol>
<li>当 a = b ，a</li>
<li>当 a &gt; b, b 和 a - b 的 gcd</li>
<li>当 b &gt; a, a 和 b - a 的 gcd</li>
</ol>
<p>当计算 gcd 时，扩展这个定义即可</p>
</blockquote>
<p>OCaml 版本如下，let 表示定义；rec 表示递归；函数参数在名字和等号之间</p>
<pre><code class="language-ocaml">* OCaml code *
let rec gcd a b = 
	if a = b then a
	else if a &gt; b then gcd b (a - b)
	else gcd a (b - 1)
</code></pre>
<p>Logic 语言，程序员制定一组公理和证明规则，可以让系统发现结果：</p>
<blockquote>
<p>gcd(a,b,g) 的论点是  （1）a,b,g 都相等 （2）a 大于 b，就存在一个 c = a - b 然后 gcd(c,b,g) 为真 ，或者 （3）a 小于 b，就存在 c = b - a 然后 gcd(c, a, g) 为真。为了计算 gcd，搜索 g 满足 gcd(a,b,g) 为真</p>
</blockquote>
<p>Prolog 版本的代码如下：</p>
<pre><code class="language-prolog">% prolog
gcd(A,B,G) :- A = B, G = A
gcd(A,B,G) :- A &gt; B, C is A-B, gcd(C,B,G)
gcd(A,B,G) :- A &lt; B, C is B-A, gcd(C,A,G)
</code></pre>
<p>应该强调的是语言家族的区分并不明确。例如冯诺伊曼语言和面向对象语言之间的界限很模糊，而且很多脚本语言也是面向对象的。大多数函数式或者 logic 语言包含命令式特性，最近的一些命令式语言包含了函数式特性。上面的描述是为了抓住家族的共有味道，而不是为了提供正式定义。</p>
<p>命令式语言--冯诺伊曼和面向对象--是本书的大部分内容。但是有兴趣的读者可以发现本书的大多数章节的替代计算模型问题涉及了跨家族问题。11-14章包含了函数式，logic，并发和脚本语言。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="为什么要学习编程语言"><a class="header" href="#为什么要学习编程语言">为什么要学习编程语言？</a></h2>
<p>编程语言是计算机科学的中心，也是典型的计算机课程。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编程语言语法"><a class="header" href="#编程语言语法">编程语言语法</a></h2>
<p>不像英语或者汉语这种自然语言，计算机语言必须是精确的。它们的结构（语法）和意义（语义）必须是无异议的，从而开发者和计算机可以知道一个程序要做什么。为了提供这种精确，语言设计者和实现者使用正式的语法和语义符号。为了便于讨论语言的特性，我们本章首先介绍语法，然后第4章介绍语义。</p>
<p>一个示例，考虑阿拉伯数字的语法表示。这些数(numberal)由数字(digit)组成，可以通过这种方式枚举（'|'表示或）</p>
<pre><code class="language-shell">digit -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8| 9
</code></pre>
<p>digit 是表示 number 的语法块。通常意义上，我们说自然数是由任意长度的非空 digit 字符串表示，以非零 digit 开始：</p>
<pre><code class="language-shell">non_zero_digit -&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8| 9
natural_number -&gt; non_zero_digit digit*
</code></pre>
<p>最后的 <code>*</code> 号表示其左侧符号零次或者多次重复。</p>
<p>当然，digit 仅仅是符号：纸上的墨水点或者屏幕上的像素。本身没有意义。我们需要为其添加语义，表示从零到九的自然数，由数学家定义。另外，我们也可以说它们表示颜色，或者日历中一周的日子。这些组成了相同语法的不同语义。类似的，我们来定义自然数的语义基于10，每个 digit 字符串的解释。可以为有理数，精度有限的实数，算术，赋值，控制流，声明，甚至所有的编程语言通过类似方式设计语法规则和语义解释。</p>
<p>区分语法和语义至少两个原因。首先，不同的编程语言经常通过不同的语法提供类似的语义。如果人们能够识别出不同语法的相似语义就能更容易的学习新语言。其次，存在一些高效优雅的算法帮助 compiler 或者 interpreter 发现计算机程序的语法结构（但是不是语义！），这些算法可以驱动编译或者解释过程。</p>
<p>本章我们集中于语法：我们如何设计编程语言的结构规则，compiler 如何识别给定程序的结构。有两个任务--确定语法规则然后根据这些规则解析给定的程序--是有区别的。对想要编写有效程序的程序员对一个任务感兴趣，compiler 对第二个任务感兴趣。第一个任务依赖 <em>regular expression 和 context-free grammars</em>，这些表明了如何构建有效的程序。第二个任务依赖 <em>scanners 和 parsers</em>，可以识别程序的结构。我们在 2.1 展开第一个任务，2.2 和 2.3 展开第二个任务。</p>
<p>在 2.4 ，我们更深入的讨论 scanning 和 parsing 的理论知识。在理论上，scanner 是有限状态机(DFA)，识别出程序的 token。parser 是确定的 push-down automaton(PDA)，识别出程序的上下文无关语法。并且证明了可以从 regular expression 和 context-free grammars 生成 scanner 和 parser。这个任务可以通过 Unix 下的 <code>lex  yacc</code>工具完成。可能除了计算机没有其他领域理论与实践之间的联系如此紧密清晰。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="21-指定语法正则表达式和上下文无关语法"><a class="header" href="#21-指定语法正则表达式和上下文无关语法">2.1 指定语法：正则表达式和上下文无关语法</a></h2>
<p>语法的形式规范需要一组规则。语法复杂性（表现力）取决于我们使用的规则。可以证明，我们直觉认为 tokens 可以通过三种规则来从单个字符集中构建：concatenation, alternation（在有限方案中选择）, 和被称为 &quot;Kleene closure&quot;（重复任意次数）。指定剩余的语法还需要一个额外的规则： recursion（通过相同结构构造简单实例）。前三种规则定义的字符串集合被称为 regular set，或者 regular language。Regular set 可以由正则表达式生成，并由 scanner 识别。然后给字符串集合加上递归被称为 <em>context-free grammars(CFGs)</em>，并且由 parser 识别。（这里的术语可能会比较困惑。“语言”这个单词的意义要放在上下文中考虑。formal 语言只是字符串集合，没有被赋予语义）。</p>
<h3 id="211-tokens-和-regular-expressions"><a class="header" href="#211-tokens-和-regular-expressions">2.1.1 Tokens 和 Regular Expressions</a></h3>
<p>Tokens 是组成程序的基本块--具有含义的最短字符串。</p>
<h3 id="212-context-free-grammars"><a class="header" href="#212-context-free-grammars">2.1.2 Context-Free Grammars</a></h3>
<p>Regular expressions 用来定义 tokens 很好。但是不能确定嵌套结构，这才是编程语言的核心。考虑一个数学表达式的结构例子：</p>
<pre><code class="language-shell">expr -&gt; id | number | - expr | (expr)
        | expr op expr
op -&gt; + | - | * | /
</code></pre>
<p>根据结构本身定义结构的能力至关重要。除了其他事项外，也能使我们确保左右括号匹配，有些不能仅通过 regular expressions 完成的事情。箭头符号（-&gt;）表示“可以具有形式”。</p>
<p>在 Context-free grammar 的每个规则被看作<em>产品</em>。作词符号是<em>variables</em>或者<em>non-terminals</em>。可能存在任意数量。构成从语法衍生出的符号称为 <em>terminals</em>。不能出现在左侧。编程语言中，上下文无关的 terminals 是语言的 tokens。nonterminal 的其中之一，在左侧的第一个出现被称为 <em>start symbol</em>。命名了语法定义的结构。</p>
<p>上下文无关语法符号被称为 Backus-Naur Form(BNF)，为了纪念 John Backus 和 Peter Naur,他们发明了 Algol-60 语言。严格来说<code>*</code>和元级别的括号不在 BNF 范围，但是它们不改变符号的表达能力，然后为了方便就看作一样的。有时还包括 <code>+</code>，表示前面符合的一个或者多个重复。当通过额外的操作扩展时，符号被称作 extended BNF(EBNF)。这个结构:</p>
<pre><code class="language-shell">id_list -&gt; id (, id)*
</code></pre>
<p>展开后</p>
<pre><code class="language-shell">id_list -&gt; id
id_list -&gt; id_list, id
</code></pre>
<p><code>+</code>是类似的。注意这里的括号时元符号。</p>
<p>就像<code>*</code>和括号，<code>|</code>貌似也比较多余。结构同样可以展开为不需要竖线的表示：</p>
<pre><code class="language-shell">op -&gt; + | - | * | /

# shorthand 
op -&gt; +
op -&gt; -
op -&gt; *
op -&gt; / 
# 或者
op -&gt; +
   -&gt; -
   -&gt; * 
   -&gt; /
</code></pre>
<p>很多 tokens，比如上面的 id 和 number，有很多可能的拼写（即很多可能的字符串表示）。parser 不关心这个。语义分析才会区分它们，scanner 必须保存每个这样“有趣”的拼写 tokens 以供后面使用。</p>
<h3 id="213-derivations-和-parse-trees"><a class="header" href="#213-derivations-和-parse-trees">2.1.3 Derivations 和 Parse Trees</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h2 id="22-scanning"><a class="header" href="#22-scanning">2.2 Scanning</a></h2>
<p>scanner 和 parser 联合起来可以用来发现一个程序的句法结构。发现的过程或者称为<em>syntax analysis</em>，是将程序转化为目标等效程序的重要第一步。通常来说，本书的剩余部分我们关注编译器而不是解释器。</p>
<p>通过将输入的字符聚合成 tokens，scanner 减少了计算密集型的 parser 必须处理的 item 数量。而且，scanner 会删除注释（因此 parser 不必担心它们在 CFG 中出现）。保存“感兴趣的”tokens 比如 identifier，string，numeric literal，带有行列信息的 tags tokens，方便后续处理中生成更友好的错误信息。我们将会创造一门简单的“计算语言”，有输入，输出，变量和赋值。比如下面的 tokens 定义：</p>
<p><img src="assets/2.2.scanning/image-20220822101601209.png" alt="image-20220822101601209" /></p>
<p>与 Algol 家族保持一致，我们使用 <code>:=</code> 而不是 <code>=</code>表示赋值。简单起见，我们省略了指数运算符，还列出了 <em>read</em> 和 <em>write</em> 作为<em>id</em>规则。注释的规则如下：</p>
<p><img src="assets/2.2.scanning/image-20220822101849285.png" alt="image-20220822101849285" /></p>
<p>我们如何识别计算器语言的 tokens？最简单的方法是 ad hoc。伪代码如下所示</p>
<p><img src="assets/2.2.scanning/image-20220822102015037.png" alt="figure-2.5" /></p>
<p>此代码很容易扩展成需要的逻辑，但是生产级编译器中更多使用自动生成状态机代码，从而方便的改变 tokens 定义，可以自动生成新的 scanner 代码。token 通常使用 “最长匹配原则”。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="24-理论基础"><a class="header" href="#24-理论基础">2.4 理论基础</a></h2>
<p>我们现在讨论的 scanner，parser，regular expression，以及 context-free grammar 都是基于自动化理论的形式化部分。在自动化理论中，所有的<em>形式化语言</em>都是从有限 <em>alphabet</em>衍生出来的字符串集合。【略】</p>
<div style="break-before: page; page-break-before: always;"></div><p>诸如 Fortran，Algol 和 Lisp 这种早期语言使用“高级别”这个术语是因为有别于汇编这种硬件相关语言，它们的语法和语义更加抽象。抽象使得它们可以写出应用于多种机器的程序，也使得程序更加容易让人类理解。机器无关性很重要，不过更重要的是编程易用推动了现代编程语言的发展。本章是首次涉及到语言设计（剩下的在6-10章）。大多数将围绕 name</p>
<p>name 是用于指代某些事物的助记字符串。在大多数语言中 name 作为 identifiers （包括字母和数字的 token），即使比如 + := 也可以作为 name。name 允许我们关联到 variable,constant,operations,types,以及底层的概念 address。name 也有上下文的第二个含义<em>抽象</em>。在这种含义下，抽象是指程序员将编译后的代码片段（funtion）与 name 关联的过程。通过隐藏不相关细节，抽象降低了概念的复杂性，开发者可以在特定时间只关注程序的一个子集。Subroutines 是<em>control abstractions</em>：允许程序员将复杂的实现隐藏在简单的接口后面。Class 是 <em>data abstractions</em>:允许程序员将数据隐藏在一系列操作之后。</p>
<p>我们将要看到 name 相关的几个主要问题。3.1 介绍了 <em>binding time</em>的概念，不仅仅是 name 如何关联起表示的东西，还包括解决任何设计实现。3.2 描述了几种分配释放对象存储空间的机制，然后区分了对象的生命周期和binding name 到对象的生命周期。大多数高级语言 name-to-object 绑定只会在限定 scope 生效。3.3 探索了 scope 规则来定义 region。3.4 考虑它们的实现。</p>
<p>在程序中给定点的完整绑定集合为看作当前的 <em>referencing environment.</em> 3.5 讨论 alias，更多的是一个 name 在给定 scope 关联一个 object，以及重载（在给定 scope 一个 name 可以关联多个 object），这取决于上下文。3.6 通过提出一个 referencing environment 可能绑定了subroutine 的参数，函数返回值或者存储的 variable， 扩展了 scope 规则的概念。3.7 讨论宏扩展，通过文本替换引入新 name，有时与语言的其他部分有点奇怪。最后，3.8 讨论了集中编写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-the-notion-of-binding-time"><a class="header" href="#31-the-notion-of-binding-time">3.1 The Notion of Binding Time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-object-lifetimes-and-storage-management"><a class="header" href="#32-object-lifetimes-and-storage-management">3.2 Object Lifetimes and Storage Management</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-scope-rules"><a class="header" href="#33-scope-rules">3.3 Scope Rules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-implementing-scope"><a class="header" href="#34-implementing-scope">3.4 Implementing Scope</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="35-the-meaning-of-names-within-a-scope"><a class="header" href="#35-the-meaning-of-names-within-a-scope">3.5 The Meaning of Names within a Scope</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="36-the-binding-of-referencing-environments"><a class="header" href="#36-the-binding-of-referencing-environments">3.6 The Binding of Referencing Environments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="37-macro-expansion"><a class="header" href="#37-macro-expansion">3.7 Macro Expansion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="38-separate-compilation"><a class="header" href="#38-separate-compilation">3.8 Separate Compilation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>如同第一章描述一样，编译器简单来说就是个翻译器。将用一种语言写出的程序转换成另一种语言。被转换的语言可以是任何语言，比如一门高层次语言，phototypesetting 命令，VLSI（芯片）布局，但是大多数时候是可用计算机的机器语言。</p>
<p>正如有很多不同的编程语言一样，也有很多种机器语言，尽管机器语言的多样性要少很多。每种机器语言对应不同的处理器架构。正式来说，架构就是硬件与软件的接口，即编译器生成的或者程序员为裸机手写的语言。处理器的实现是架构在硬件的实现。为了生成正确的代码，编译器作者只需要理解目标架构。为了生成高效的代码，还要了解实现，因为这决定了生成代码的执行速度。</p>
<hr />
<p>网站有更详细的介绍，比如 x86 的 CSIC 指令集，以及 ARM 的 RISC 指令集。</p>
<p>更详细的请看<a href="../assets/chapter_05.pdf">chapter5</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>在第一部分的基础上，我们现在来讨论大多数编程语言核心的问题：控制流，数据类型，以及控制和数据的抽象。</p>
<p>第6章讨论控制流，包括 expression evaluation, sequencing, selection, iteration, and recursion. 很多时候我们看到设计决策反映了对于互补或者竞争策略概念和效率上的权衡。引用和值的区别，提前或者懒惰计算问题会在后续章节反复出现。</p>
<p>接下来两章讨论类型。第7章包括类型系统和类型检查，包括等效性，兼容性和类型推断等概念。还讨论了显式和隐式形式的参数多态。第8章介绍了 compsite type 的最新研究，包括 records, variants, arrays, strings, sets, pointers, lists, files。指针部分介绍了垃圾收集技术。</p>
<p>控制和数据都可以抽象，即复杂性隐藏在简单以及定义明确的接口之后的过程。控制抽象是第9章的内容。subroutines 是最常见的控制抽象，但是我们也要考虑 exception 和 coroutine，然后简单回顾第6章介绍的 continuations and iterators。subroutines 主要包括调用顺序和参数传递机制。</p>
<p>第10章回到数据抽象。很多现代编程语言是面向对象的，通过封装机制，继承，和方法的动态分发（子类型多态）。我们对于面向对象编程语言的讨论主要包括构造器，访问控制，范型，闭包，以及 mix-in 和多继承。</p>
<div style="break-before: page; page-break-before: always;"></div><p>已经探究了编译器用来进行语法分析的机制以及必须生成目标机器代码的特性。我们现在返回到语言设计中的核心问题。具体来说，本章讨论控制流问题，或者叫做程序执行顺序。顺序对于大多数计算模型是很重要的。决定了为了完成一些任务，那条指令先执行，那条后执行。我们可以将语言中顺序的机制划分几类：</p>
<ol>
<li>Sequencing：statement 按照确定顺序执行（或者 expression evaluated），通常就是程序呈现的顺序</li>
<li>Selection：根据执行期间的条件，在两个或者多个 statement 或 expression 之间选择。最常见的选择结构是 <code>if</code> <code>case(switch)</code> statement。选择有时候也被称为 <em>alternation</em></li>
<li>Iteration：给定的代码片段重复执行特定次数或者满足执行期间的条件。迭代结构包括 <code>for/do, while, repeat</code></li>
<li>Procedural abstraction：一系列复杂控制结构的封装（subroutine ），可以作为单独的单元，而且可以接受参数</li>
<li>Recursion：expression 被自己直接或者间接定义；计算模型使用栈来保存部分计算信息。递归通常使用子引用 subroutine 来定义</li>
<li>Concurrency：两个或者多个程序片段“同时”执行，要不在不同处理器分开执行，要不在同一处理器实现相同的并行效果</li>
<li>Exception handling and speculation：程序片段假定一些条件为真乐观执行，如果条件为假，执行分支转到执行保护片段（excepiton handling），或者代替为保护片段（speculation）。对于 speculation，语言实现必须可以 undo，或者 “roll back”被保护代码的可见部分。</li>
<li>Nondeterminacy：statement 或者 expression 的顺序或者选择故意不指定，表示都可以导致正确结果。从某种意义上来说，有些语言要求选择随机公平。</li>
</ol>
<p>尽管句法和语法细节语言之间大有不同，但这些类别的顺序控制结构可以在大多数语言中发现。一个程序猿如果从这些类别来学习新语言，评估语言之间设计的权衡，算法的选择，而不是陷入到语言的语法细节中会更容易。</p>
<p>Subroutines 是第9章的内容，并发是第 13 章的内容。异常处理在 9.4 和 13.4.4 中会分别讨论。本章会讨论剩下的几种类别。在 6.1 我们来讨论表达式的求值（expression）-- 所有高级顺序的基础表达块。来讨论 expression 的句法表示，操作符的优先级和关联性，操作数的执行顺序以及赋值的语法。尤其需要关注的是关联值的变量和关联引用的变量之间的区别。在 6.2 我们讨论结构化和非结构化（goto）的控制流程。</p>
<p>不同类别的控制流在不同语言中的重要性差别很大。sequencing 是命令式语言（冯诺依曼，面向对象语言）的核心，但是在函数式语言中的角色就小一些，函数式语言强调 evaluation of expression，否定或者消除影响程序输出的 statements。类似的，函数式语言大量使用递归，命令式语言更喜欢迭代。逻辑语言倾向于消除或者隐藏顺序控制：开发者描述推理规则，语言实现负责找到应用这些规则的顺序。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>在第 3 章我们描述了数据抽象的多个阶段，重点是 scope 机制下控制名称的可见性。我们从全局变量开始，它的生命周期贯穿程序执行期。然后讨论局部变量，它的生命周期限制在单个 subroutine 执行期间；嵌套 scope，允许 subroutine 自己为局部的；静态变量，它的生命周期也贯穿程序执行期，但是名称仅在单个 subroutine 可见。随后是模块，允许一组 subroutine 共享一组静态变量；模块类型，允许开发者实例化多个给定抽象；类，允许开发者定义一族相关抽象。</p>
<p>原始的模块鼓励“管理者”风格的编程，模块到处为抽象类型。模块类型和类允许模块自己就是抽象类型。这种区别在两个方面。首先，显示 <code>create</code> <code>destroy</code> 过程需要从管理者模块导出，可以被模块类型实例的创建和销毁代替。其次，模块实例的方法调用代替了将导出类型作为参数传递的过程调用。类就是建立在模块作为类型机制上，然后增加了继承机制，继承允许通过扩展或者修改现有的抽象实现新的抽象，以及动态方法绑定，这可以使得新版本的抽象执行新的行为，或者在上下文中使用早版本的内容。一个类的实例被称为对象，基于类的语言或者编程称为面向对象。</p>
<p>在第 3 章中对于数据抽象的逐步演化是组织想法的很有用的方法，但是并不能完整反映语言特性的发展。尤其是，对于面向对象编程的发展是基于模块发展的描述是不准确的。相反，面向对象编程的三个基本概念（封装，继承和动态方法绑定）都起源于18世纪60年代中期的 Simula 语言。对于现代的面向对象语言，Simula 在数据封装上显得比较弱，在1970年代 Clu, Modula, Euclid 在这个方面做出了重要贡献。同时，继承和动态方法绑定结合的思想也发生在 1970 年代。</p>
<p>Smalltalk 采用了独特的“基于消息”的编程模型，具有动态类型和不常见的语法。动态类型使得实现相对较慢，而且延迟了错误报告。该语言还紧密整合到了图形编程环境中，因此很难跨系统移植。由于这些原因，并没有被广泛使用，并对后面的语言产生了影响。比如 Eiffle， C++，Ada 95， Fortran 2003， Java，C# 在很大程度上是 Smalltalk 中继承和动态方法绑定和“主流”命令式语言词法和语法的重新融合。另一条线是，Object-C 结合了 Smalltalk 风格的消息和动态类型，并以相对纯粹的方式结合了 C 的语法进行对象操作。对象的方向在函数式语言中也变得重要起来，比如 Lisp 对象系统，和 OCaml 的对象。</p>
<p>最近，动态类型对象重新在 Python 和 Ruby 中获得了知名度，同时静态类型对象作为 Object-C 的继任者（跟随 OCmal）也出现在了 Scala ，Go 和 Swift 中，将动态类型对象建立在静态类型语言中。</p>
<p>在 10.1 中我们概述面向对象编程以及三个主要概念。在 10.2 中讨论数据隐藏和封装的细节。然后在 10.3 中讨论对象初始化和 finalization，以及 10.4 中的动态方法绑定。在 10.6 中（大多数内容在网站上<a href="../assets/supplementary_sections.pdf">这里也有</a>）考虑多重继承。正如我们看到的多重继承引入了一些特别棘手的语法和实现挑战。最后，在10.7中，我们重新审视面向对象的定义，考虑语言应该或者在多大程度上讲所有事物作为对象进行建模。我们大多数讨论集中在 Smalltalk，Eiffel，C++，Java，只会少量提及其他语言。我们在 14.4.4 中会重新回到动态类型对象的讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><p>面向对象编程可以看作通过已经存在的抽象进行扩展或者改进来重用代码的尝试。首先看一个例子，考虑一个整数集合，通过双向链表来实现。【译者注：这里的代码描述和相关叙述参考原书，翻译比较麻烦，而且很容易看懂】</p>
<p>关键词：</p>
<ul>
<li>
<p>Data member(field)</p>
</li>
<li>
<p>subroutine member(method)</p>
</li>
<li>
<p>public / private members</p>
</li>
<li>
<p>Derived Class (child class or subclass) &lt;-&gt; Base class (parent class or superclass)</p>
</li>
<li>
<p>modifying base class methods</p>
</li>
<li>
<p>Objects as Fields of Other Objects (组合，非继承)</p>
<p>think as or is</p>
</li>
</ul>
<h3 id="1011-classed-and-generics"><a class="header" href="#1011-classed-and-generics">10.1.1 Classed and Generics</a></h3>
<p>精明的读者可能已经注意到上面的例子中 list 和 queue 其中的元素都是整数。实际上我们可能有很多其他元素的 list 和 queue，代码都很相似。在动态类型语言（Ruby 或者 Python）中，这很自然： val 没有 static 类型，任何类型的对象都可以。</p>
<p>在 C++ 这种静态类型语言中，需要一种通用的方式来创建不同元素的 list 和 queue。当然，可以通过定义基类，然后派生部分完成这个任务，但是如果基类中需要传入元素就很难完成这个任务。答案当然是 C++ 的模板。允许我们定义 class<T> 这种方式。</p>
<p>简而言之，模板的存在为了抽象类型无关，有些继承无法完成的目的。除 C++ 外，通用技术还出现在其他静态类型面向对象语言，比如 Eiffel， Java， C# 和 OCaml。</p>
<div style="break-before: page; page-break-before: always;"></div><p>封装机制确保开发者将数据和操作数据的行为组织到一起，将行为细节对用户隐藏。在先前的章节中，我们将面向对象作为“module-as-type“机制的扩展。也可以将面向对象放在“module-as_manager”框架中。下面的第一小节，我们考虑在非面向对象语言中的数据隐藏机制 module。第二小节中我们考虑当引入继承到 module 之后新的数据隐藏问题。在第三小节，我们简要回顾 module-as-manager 方法，展示几种语言包括 Ada 95 和 Fortran 2003 如何增加继承，从而允许 (static) module 允许继续提供数据隐藏。</p>
<h3 id="1021-modules"><a class="header" href="#1021-modules">10.2.1 Modules</a></h3>
<p>数据隐藏的 Scope 规则是 Clu, Modula, Euclid 和其他基于模块的 1970 年代的语言的主要创新。在 Clu 和 Euclid 中，module 的声明和定义总是在一起出现。在 Modula-2 中，开发者可以选择性的将声明和定义在不同文件。不幸的是，没有办法将声明分为 public / private 部分，所有的东西都是 public。唯一的数据隐藏是允许指针类型声明在 header 里，然后不透露指向的对象结构。编译器可以生成代码，因为指针类型大小都是一样的。</p>
<p>Ada 通过将 header 分为 public 还是 private 提升了复杂性。导出的类型细节可以放在 private 部分，然后在 public 只有名字。</p>
<p>分配堆和栈的解释。</p>
<h4 id="this-parameter"><a class="header" href="#this-parameter">‘this’ parameter</a></h4>
<p>module 内部的 subroutine 出现了问题。它们如何知道哪个被使用？当然可以给每个实例复制一份代码，就像复制数据一样。但是复制很浪费，仅仅在地址计算上有所不同。更好的方法是创建一个 subroutine 单例，然后在运行时，然后将实例地址传递给单例，这个地址就是隐藏的每个 subroutine 的第一个参数。</p>
<pre><code class="language-Euclid">my_stack.push(x) -&gt; push(my_stack, x)
</code></pre>
<h4 id="making-do-without-moudle-headers"><a class="header" href="#making-do-without-moudle-headers">Making do without Moudle Headers</a></h4>
<p>C++ 的 namespace 可以跨编译单元，一个文件也可以包含多个 namespace。与此同时，很多现代语言，比如 Java 和 C#，不需要显式声明 header 和 body。开发者只需要定义接口，如果需要 header，有工具可以帮助开发者提取，而不需要手动编写。</p>
<h3 id="1022-classes"><a class="header" href="#1022-classes">10.2.2 Classes</a></h3>
<p>随着继承的引入，面向对象语言必须解决基于 module 的 scope 规则无法覆盖的问题。比如，如何控制基类成员在派生类中的访问规则？基类的 private 应该被派生类访问吗？基类的 public 总是应该被派生类访问吗？</p>
<p>C++ 中基类的 private 在派生类中还是 private，public 也是，但是 C++ 允许派生类显式删除基类的 public 成员：</p>
<pre><code class="language-cpp">class queue: public list {
  ...
  void append(list_node *new_node) = delete;
}
</code></pre>
<p>类似的机制还可以在 Eiffel, Python, Ruby 中发现。</p>
<p>除了 public 和 private 标签，C++ 还有 protected 标签。protected 成员只在基类和派生类中可见。当然，protected 也可以用在描述基类的位置：</p>
<pre><code class="language-cpp">class derived: protected base {...}
</code></pre>
<p>这样基类中的 public 成员在派生类中就是 protected 成员。C++ 规则可以总结如下：</p>
<ul>
<li>类可以限制成员的可见级别。public 可以在 class 声明的 scope 可见。private 只能被类成员可见。protected 只在基类和派生类成员可见。（例外情况是，可以声明 friend 类和 subroutine，访问自己的 private 成员）</li>
<li>派生类可以限制基类成员的访问级别，但是不能扩大。通过声明基类 protected, private</li>
<li>派生类可以限制基类成员的访问级别，但是派生类中，可以通过 using 声明恢复基类的访问级别（注意是恢复，还是不能扩大）</li>
<li>派生类可以通过 delete 使得方法不可被访问。</li>
</ul>
<p>其他面向对象语言有不同的方法控制级别。比如 Eiffel 不仅可以限制，而且可以在派生类中提升基类成员的可见级别。</p>
<p>Java 和 C# 继承了 C++ 的标签，但是不提供 protected 和 private 的关于基类的继承描述，派生类不能限制也不能扩大基类的访问级别。</p>
<p>protected 在 Java 中还有比 C++ 中不同的含义： protected 成员不仅在派生类中可见，而且在 package 中可见。C# 的 protected 就像 C++ 中一样，不过还提供了 internal 关键字使得成员在类出现的汇编组件中可见（汇编组件是一系列链接在一起的编译单元，类似 java 中的 .jar 包），C# 中成员默认是私有的。</p>
<p>在 SmallTalk 和 Object-C 中，没有成员可见级别的问题：都是 public 的，Python 也是。Ruby 都是 private。</p>
<h4 id="static-fields-and-methods"><a class="header" href="#static-fields-and-methods">Static Fields and Methods</a></h4>
<p>除了 public, private, protected 的可见级别标签，大多数面向对象语言还允许字段或者方法使用 static 描述。static 类成员被认为属于整个类，而不是单个对象。static 方法没有 this 参数，不能访问非 static 成员或者字段。</p>
<h3 id="1023-nestinginner-classes"><a class="header" href="#1023-nestinginner-classes">10.2.3 Nesting(Inner Classes)</a></h3>
<p>很多语言允许类嵌套声明。那么问题是：如果 Inner 是 Outer 的成员，Inner 的方法可以访问 Outer 的成员吗，如果可以，如何实现？C++ 和 C# 中采用的最简单实现，只允许访问 Outer 的静态成员。实际上，嵌套仅作为信息隐藏的手段。Java 采用了更复杂的方案，允许 Java 中的嵌套类访问周围类的任何成员。因此每个内部类的实例必须属于外部类的某个实例。</p>
<pre><code class="language-java">class Outer {
  int n;
  class Inner {
    public void bar() {n = 1;}
  }
  Inner i;
  Outer() {i = new Inner();} // constructor
  public void foo() {
    n = 0;
    System.out.println(n); // prints 0
    i.bar();
    System.out.println(n); // prints 1
  }
}
</code></pre>
<p>如果有多个 Outer 实例，每个实例有不同的 n， Inner.bar 的调用必须访问正确的 n。所以，每个 Inner 实例要有 Outer 实例的指针。如果 Java 的嵌套类被声明为 static，就像 C++ 和 C# 一样，只能访问周围类的静态成员。</p>
<p>Java 类也可以嵌套在方法内。这种 local 类不仅能访问周围类的成员，方法的参数和变量也可以。【译者注：更详细规则感兴趣请参考原文】</p>
<p>Inner 和 local 类在 Java 中被用于创建对象闭包。在 9.6.2 中我们用来处理事件。并且，local 类可以是匿名的：可以内联出现在 new 方法内。</p>
<h3 id="1024-type-extensions"><a class="header" href="#1024-type-extensions">10.2.4 Type Extensions</a></h3>
<p>Smalltalk，Objective-C, Eiffel, C++, Java, C# 都是一开始就设计为面向对象的语言，要么就是从一门没有强力封装机制的语言演化而来。都支持 module-as-type 的抽象，其中类机制提供了封装和继承。几种其他类型的语言，包括 Modula-3, Oberon, CLOS, Ada 95/2005, Fortran 2003 可以被描述为在 module 已经支持了封装之后的面向对象扩展的语言。这些语言没有改变现有的 module 机制，而是通过扩展 record 的方式提供了动态方法绑定和继承。</p>
<p>【译者注：关于更多细节请参考原书本节，译者不了解 Ada 语言，以免翻译出错】</p>
<h3 id="1025-extending-without-inheritance"><a class="header" href="#1025-extending-without-inheritance">10.2.5 Extending without Inheritance</a></h3>
<p>扩展现有抽象功能是面向对象编程的主要动机之一。继承可能是扩展的标准机制。但是有时候，不能使用继承的时候，比如处理已经存在的代码，类也想要扩展：比如 Java 中 final 标签的；C# 中使用了 sealed。即使原则上继承可用，但是比如有大量已存在代码使用了原来的类名，返回更改所有变量的声明为派生类不是很好的方式。</p>
<p>对于这些场景，C# 提供了 extension 方法，可以扩展已有的类：</p>
<pre><code class="language-c#">static class AddToString {
  public static int toInt(this string s) {
    return int.Parse(s);
  }
}

int n = myString.toInt();
</code></pre>
<p>extension 方法必须是 static，也必须声明为 static 类。第一个参数也必须 this 前缀。这个方法就可以作为该类的方法被调用。</p>
<p>实际上，这个方法声明就是语法糖： </p>
<pre><code class="language-c#">static class AddToString {
  public static int toInt(string s) {
    return int.Parse(s);
  }
}
...
int n = AddToString.toInt(myString);
</code></pre>
<p>没有什么特别的。需要注意的是，extension 方法它们不能访问类的 private 成员和动态绑定的方法。相反，几种脚本语言，包括 JavaScript 和 Ruby，允许开发者向已经存在的类中添加方法，我们在 14.4.4 中讨论这些。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在 3.2 中我们定义了对象的生命周期，周期内对象可以占用空间，持有数据。大多数面向对象语言提供了对象生命周期开始时进行特定顺序初始化的机制。当使用 subroutine 方式写时，这种机制被称为构造器。尽管这个名字可能有其他方面的暗示，但是构造器不分配空间；只初始化已经分配好的空间。有些语言提供了类似的析构机制，在对象生命周期结束自动调用。几个重要问题出现了：</p>
<ul>
<li>选择一个构造器：面向对象语言可以有零个，一个，多个不同的构造器。后面的情况，不同的构造器可能会有不同的名字，或者有必要根据它们参数的数量和类型进行区分。</li>
<li>引用和值：如果变量是引用，每个对象必须被显式创建，这就很容易确保适当的构造器被调用。如果变量是值，对象创建可能是隐式的。后面这种情情况，语言必须允许对象未初始化，或者必须提供一种方法为每种对象选择合适的构造器。</li>
<li>执行顺序：C++的派生类，编译器必须保证基类的构造器先被执行。此外，如果一个类有一些其他类的成员，成员的构造器也必须先被调用。这些规则是语法和语义复杂性的来源之一：组合多个构造器，可变对象，多重继承之后，会出现复杂的构造器调用顺序，重载分析。其他语言会简单点。</li>
<li>垃圾收集：大多数面向对象语言提供了构造机制，析构相对少很多。主要目的是减轻 C++ 中手动垃圾回收的负担。如果语言实现中包括垃圾收集，析构是不需要的。</li>
</ul>
<p>本章剩余部分，详细分析这几个方面的细节。</p>
<h3 id="1031-选择一个构造器"><a class="header" href="#1031-选择一个构造器">10.3.1 选择一个构造器</a></h3>
<p>Smalltalk，Eiffel，C++，Java 和 C# 允许开发者指定超过一个构造器。在 C++，Java，C#中，构造器就像可以重载的方法：必须通过参数数量和类型区分。在 Smalltalk 和 Eiffel 中，不同的构造器可以有不同的名字，创建对象必须是显式的。</p>
<h3 id="1032-引用和值"><a class="header" href="#1032-引用和值">10.3.2 引用和值</a></h3>
<p>【译者注：引用模型和值模型，译者理解就是堆变量和栈变量】</p>
<p>很多面向对象语言，包括 Simula, Smalltalk, Python, Ruby, Java 使用变量关联对象的编程模型。一些语言，包括 C++ 和 Ada 允许变量有值（对象（。Eiffel 默认使用引用模型，但是允许开发者指定类需要被展开，意味着变量有值。类似的，C# 和 Swift 使用 struct 定义有值的类型，class 定义引用的类型。</p>
<p>对于变量的引用模型，每个对象显式创建，很容易确保调用了正确的构造函数。对于变量的值模型，对象可以隐式创建。在 Ada 中，默认不提供构造器的自动调用，对象开始都是未初始化的，就可能在有值前使用值。在 C++中，编译器确保每个对象的构造器的调用，但是规则有时候很复杂。</p>
<p>如果 C++ 类类型 foo 的变量未初始化声明，编译器会调用零参数构造器（如果没有这样的构造器，但是有其他构造器，编译器会报错）。</p>
<p>如果开发者想要不同的构造器，必须显式声明构造器的参数。拷贝构造器：在声明一个变量时，即使使用 = ，也是调用拷贝构造器。赋值运算符重载被调用，只发生在已经存在的变量重新赋值。</p>
<p>【译者总结】：RVO（return value optimization） 与构造器。</p>
<h3 id="1033-执行顺序"><a class="header" href="#1033-执行顺序">10.3.3 执行顺序</a></h3>
<p>正如我们看到的，C++ 坚持对象使用之前是被初始化的。此外，如果类是派生的，C++ 先调用基类的构造器，再调用派生类自己的。</p>
<pre><code class="language-cpp">foo::foo(foo_params): bar(bar_args) {}
</code></pre>
<p>Java 的规则也一样。语法更简单一点，<code>super(args)</code>。</p>
<h3 id="1034-垃圾收集"><a class="header" href="#1034-垃圾收集">10.3.4 垃圾收集</a></h3>
<p>当 C++ 对象被销毁，派生类的析构首先被调用，然后是基类的，与构造器的顺序相反。析构的最常见作用是自动释放申请的存储。</p>
<p>在现代 C++ 代码中，存储管理通常使用智能指针。具体实现就是，在析构器中判断，指针指向的对象是否还存在，不存在就回收指针指向的对象。</p>
<p>在自动收集的语言中，不需要析构器。事实上，</p>
<div style="break-before: page; page-break-before: always;"></div><p>继承的主要后果是派生类拥有了基类所有的成员和方法。这允许派生类用在所有基类可用的地方。换句话说，派生类不隐藏基类成员。</p>
<p>这种在使用基类上下文中使用派生类的能力称为 subtype polymorphism（子类型多态）。想象我们需要一个大学管理员计算系统，我们可以从 person 类中派生 student 和 professor。因为 student 和 professor 都拥有 person 的所有特性。我们可以将它们用在 person 的上下文中</p>
<pre><code class="language-cpp">student s;
professor p;
...
person *x = &amp;s;
person *y = &amp;p;
</code></pre>
<pre><code class="language-cpp">void persion::print_mailing_label() {...}
</code></pre>
<p>通过参数的类型可以是多态的</p>
<pre><code class="language-cpp">s.print_mailing_label(); // print_mailing_label(s)
p.print_mailing_label(); // print_mailing_label(p)
</code></pre>
<p>与其他形式的多态一样，我们取决于以下事实：print_mailing_label 使用实参的特性。</p>
<p>但是假定我们在每个派生类中重新定义了 print_mailing_label 。多态就取决于对象：</p>
<pre><code class="language-cpp">s.print_mailing_label(); // student::print_mailing_label(s)
p.print_mailing_label(); // professor::print_mailing_label(p)
</code></pre>
<p>但是，这种情况呢：</p>
<pre><code class="language-cpp">x-&gt;print_mailing_label();
y-&gt;print_mailing_label();
</code></pre>
<p>要调用的方法取决于 x 和 y 的类型？还是指针指向的对象类型？</p>
<p>第一种选项（use the type of the reference）被称为 static method binding。第二种选项（use the class of the object ）被称为 dynamic method binding。动态方法绑定是面向对象编程的核心。</p>
<h4 id="语法和性能"><a class="header" href="#语法和性能">语法和性能</a></h4>
<p>关于静态方法绑定的主要争论----动态方法绑定基于引用对象的类型----静态方法绑定不能体现派生类自身状态的一致性。比如，我们建立一个 I/O 库，包含  text_file 类：</p>
<pre><code class="language-cpp">class test_file {
  char *name;
  long position; // file pointer
 public:
  void seek(long whence);
  ...
};
</code></pre>
<p>现在假定我们有派生类 read_ahead_text_file:</p>
<pre><code class="language-cpp">class read_ahead_text_file: public text_file {
  char *upcoming_characters;
 public:
  void seek(long whence); // redefinition
  ...
};
</code></pre>
<p>毫无疑问 read_ahead_text_file 的 seek 需要改变 upcoming_characters 的值。如果方法不是动态绑定的，我们不能保证这一点：如果传递 read_ahead_text_file 的引用给 text_file 形参的 subroutine，然后 subroutine 调用了 seek，我们实际调用了基类的 seek。</p>
<p>不幸的是，我们将在 10.4.3 中看到，动态方法绑定引入了运行时开销。即使这种开销通常不大，不过对于性能关键型的小型程序来说，仍然是一个问题。Smalltalk, Objective-C, Python, Ruby 对所有方法使用动态方法绑定。Java Eiffel 默认使用动态方法绑定，但是可以显式声明 final(Java) frozen(Eiffel) 不能在派生类中 override，因此可以优化实现。Simula,C++, C#, Ada 95 默认使用静态方法绑定，但是允许开发者需要时使用动态方法绑定。最后这种情况，需要区分术语，override 是动态方法绑定，redefining 静态方法绑定的方法。为了清楚起见，C# 需要声明关键字 override，new 当派生类需要 override 或者 redefine 方法的时候。Java 和 C++11 也有类似的推荐的注解，但不是必须的。</p>
<h3 id="1041-virtual-and-nonvirtual-methods"><a class="header" href="#1041-virtual-and-nonvirtual-methods">10.4.1 Virtual and Nonvirtual Methods</a></h3>
<p>在 Simula，C++ 和 C# 中，默认使用静态方法绑定，开发者需要对使用动态方法绑定的方法使用 virual 标签。对于 virtual 方法的调用会在运行时调用合适的实现，基于对象的真实类，而不是引用的类型。在 C++ 和 C# 中，virtual 前缀在方法前使用。</p>
<p>Ada 95 使用不同的方式。不将特定的方法与动态分发关联起来，Ada 95 的开发者使用特定引用关联。【译者注： Ada 95 的具体方式请参考原文】</p>
<h3 id="1042-abstract-classes"><a class="header" href="#1042-abstract-classes">10.4.2 Abstract Classes</a></h3>
<p>在大多数面向对象语言中，可能会在基类中忽略 virtual 方法的定义。在 Java 和 C# 中，可以使用 abstract 标签在类上，然后方法也使用 abstract ：</p>
<pre><code class="language-java">abstract class persion {
  public abstract void print_mailing_label();
}
</code></pre>
<p>C++ 中没有这么直观：在 subroutine 后面“赋值”为0，表示抽象方法是纯虚函数：</p>
<pre><code class="language-cpp">class persion {
 public:
  virtual void print_mailing_label() = 0;
}
</code></pre>
<p>无论声明语法如何，有至少一个抽象方法就是抽象类。不可能实例一个抽象类，因为缺失至少一个成员。抽象类的唯一作用就是作为基类。具体类必须提供抽象方法的重载。基类中抽象方法的存在为动态方法绑定提供了“hook”，允许开发者在调用处使用基类的引用，然后在运行时调用正确的方法。除了抽象方法没有字段成员，没有方法定义在Java， C#， Ada 2005 中称为 interface。支持了“混合”多重继承，我们在 10.5 中讨论。</p>
<h3 id="1043-member-lookup"><a class="header" href="#1043-member-lookup">10.4.3 Member Lookup</a></h3>
<p>对于静态方法绑定来说（Simula，C++，C#，Ada 95），编译器总是可以基于变量类型知道那个版本的方法被调用。但是，动态方法绑定需要指针或者引用包含对象足够的信息来让编译器在代码生成时运行时找到正确的方法版本。最常见的实现是在每个对象的第一个位置包含 vtable 的地址。vtable 是一个数组，第 i 个元素表明了对象的第 i 个 virtual 方法。所有实例共享这一个 vtable。</p>
<p><img src="assets/10.4.dynamic_method_binding/image-20220901163754460.png" alt="image-20220901163754460" /></p>
<p>假定 this 指针通过寄存器 r1 保存，m 是 class foo 的第三个方法，f 是指向 foo 的指针。f-&gt;m() 就像这样：</p>
<pre><code class="language-assembly">r1 := f
r2 := *r1 // vtable address
r2 := *(r2 + 3 - 1 * 4) // assuming 4 = sizeof(address)
call *r2
</code></pre>
<p>如果 bar 继承了 foo，将字段放在后面，然后创建一个新的 vtable 复制 foo 的，然后修改 bar 重载的方法地址以及新增 bar 定义的（如上图）。如果有一个 bar 对象，可以安全将其地址赋值给 foo*。</p>
<p>C++ 允许“向后兼容”赋值，通过 dynamic_cast 运算符</p>
<pre><code class="language-cpp">s = dynamic_cast&lt;bar*&gt;(q); // performs a run-time check
</code></pre>
<p>如果运行时检查失败，s 被赋予空指针。为了向后兼容，C++ 也支持 C 风格的类型转换 <code>s = (bar*)q; // permitted, but risky</code>，这种风格的类型转换需要开发者确保类型正确：不会执行运行时检查。</p>
<p>Java 和 C# 使用用了传统的类型转换注解，但是会运行时检查。Eiffel 有 ?= 操作符，就像 C++ 的 dynamic_cast。</p>
<p>如同 7.3 所述，Smalltalk 使用“鸭子类型”： 变量是没有类型的引用，可以赋值任何类型的对象。代码真正调用时，语言检查对象是否支持这个操作，如果支持，对象类型就是可接受的。这种实现很简单：对象的字段永远不是 public 的，与对象的交互都由方法来完成。对象的布局开始就是类型描述。类型描述包括一个字典，将方法名称映射到代码段。运行时，Smalltalk 解释器执行查找操作发现方法是不是支持的，如果不支持，生成错误提示--Lisp 风格的。CLOS，Objective-C, Swift, 和面向对象的脚本语言提供类似的语义和类似的实现。动态方法确实比静态方法灵活，但是引入了开销和延迟错误报告。</p>
<p>除了间接增加了开销，virtual 方法通常不能在编译时进行 subroutine 内联展开。而内联的缺失在代码段短小而且被频繁调用时会产生很大的开销。像 C/C++ 尽可能避免运行时开销：因此默认使用静态方法绑定，并且严重依赖对象值变量，这种 virtual 方法也可以在编译器确定。</p>
<h3 id="1044-object-closures"><a class="header" href="#1044-object-closures">10.4.4 Object Closures</a></h3>
<p>我们已经注意到（在 3.6.4 以及其他地方）对象闭包可以在面向对象语言中实现过程闭包相似的效果--为后续执行方法捕捉上下文。应该注意到，这个机制以来动态方法绑定。举例，将 3.36 适配 9.23 的代码，使用模板重写: </p>
<pre><code class="language-cpp">template&lt;typename T&gt;
class un_op {
 public:
  virtual T operator()(T i) const = 0;
};

class plus_x: public un_op&lt;int&gt; {
  const int x;
 public:
  plus_x(int n): x(n) {}
  virtual int operator()(int i) const {return i + x;}
};

void apply_to_A(const un_op&lt;int&gt;&amp; f, int A[], int A_size) {
  int i;
  for (i = 0; i &lt; A_size; i++) A[i] = f(A[i]);
}
...
int A[10];
apply_to_A(plus_x(2), A, 10);
</code></pre>
<p>任何派生自 <code>un_op&lt;int&gt;</code> 的对象都可以传递给 apply_to_A 。因为 operator 是 virtual 的，所以可以“正确”调用。</p>
<p>很多应用有一个有用的惯用法就是包装方法和其参数在对象闭包中方便后续调用。如下示例：</p>
<p><img src="assets/10.4.dynamic_method_binding/image-20220901171141725.png" alt="image-20220901171141725" /></p>
<p>这种技术在 C++11 已经被支持地比较好，可以省略 <code>fn_call</code> 和 <code>call_foo</code> 的编写。函数 <code>schedule_at</code> 可以被定义对象 <code>std::function&lt;void()&gt;</code>作为第一个参数，10.5 中的 cf 可以声明为 </p>
<pre><code class="language-cpp">std::function&lt;void()&gt; cf = std::bind(foo, 3, 3.14, 'x');
</code></pre>
<p><code>bind</code> 将函数与其参数打包在一起作为对象。标准库还提供了 placehoulder 机制打包部分参数，因此传递给函数对象的参数可以填充到剩余位置。</p>
<p>对象闭包也被用在 Java 中（以及其他语言中），为了封装新创建的控制线程的启动参数（在 13.2.3 中详细介绍）。也可以用来实现访问者模式实现迭代器。</p>
<div style="break-before: page; page-break-before: always;"></div><p>当建立面向对象系统时，通常设计一个完美的继承树（每个类有一个确切的父类）非常困难。cat 可能是 animal, pet, family_member, object_of_affection。widget 在公司数据库中可能是 sortable_object（从上报系统角度）, graphable_object（从窗口系统角度）, 或者 storable_object（从文件系统角度），我们如何选择呢？</p>
<p>通常来说，我们可以想象一个类可以有任意数量的父类，每个父类提供了 field 和 method （抽象或者确定的）。C++，Eiffel，CLOS，OCaml，Python 提供了多重继承来支持，我们在 10.6 中讨论，不幸的是，它引入了大量语义上和运行时的复杂性。实际上，我们更需要的是一种限制性机制，称为混合继承。</p>
<p>比如，考虑 widgets。上报系统需要 widget 可以排序，窗口系统需要 widget 可以展示在屏幕上。为了满足这些需求，提供了混合继承的语言可以让开发者定义对象必须提供的 interface。对于 widget，上报系统可以定义 <code>sortable_object</code> 接口，窗口系统可以定义 <code>graphable_object</code> 接口，文件系统可以定义 <code>storable_object</code> 接口。这些接口不提供具体的实现，widget 设计者需要提供实现。</p>
<p>正如 10.4.2 中所述，接口就是不包含 field 和具体 method 的类。类只继承一个“真正的”父类，然后“混合”实现多个接口。如果 subroutine 参数类型声明为接口类型，实现接口的类都可以作为实参传递。对象也不需要有一个共同的祖先。</p>
<p>最近这些年，混合称为一个通用的方法----可以说是主要方法---来实现多重继承。尽管不同语言的细节不同，但是接口出现在了 Java, C#, Scala, Objective-C, Swift, Go, Ada 2005, Ruby 等语言中。</p>
<p>回到我们的 widget 例子，假定我们已经有了 Java 代码：根据文本部分排序，在 web 浏览器展示，存储在文件数据结构中。每种能力通过接口表达。如果我们已经开发了一些复杂的 widget 一项，我们可以讲接口混合到类中来利用通用代码。【译者注：例子请参考原书】</p>
<h3 id="1051-实现"><a class="header" href="#1051-实现">10.5.1 实现</a></h3>
<p>在比如 Ruby，Objective-C, Swift 这些使用动态方法查找的语言中，接口的方法可以简单加入到任何类的方法字典中。在任何需要接口类型的上下文中，查找机制可以找到适当的方法。具有静态类型的语言中，方法的指针被放在 vtable offset 位置，需要新的机制引入。挑战是对一个对象的多种视角。</p>
<p><img src="assets/10.5.mix_in_inheritance/image-20220831154025273.png" alt="image-20220831154025273" /></p>
<p>指针指向对象偏离开始的 offset 被称为 'the correction'，存在 vtable 的开始。</p>
<p>假定现在我们需要调用 augmented_widget 对象 w，它的地址当前在寄存器 r1。编译器知道 w 的 storable_object vtable 指针的偏离，所以可以对 r1 加 c。那么，当调用 storable_object 的 get_stored_name 会发生什么？假定 storable_object 的视角是正确的，在寄存器 r1，编译器会生成类似下面的代码： </p>
<pre><code class="language-assembly">r2 := *r1 -- vtable address
r3 := *r2 -- this correction
r3 +:= r1 -- address of w
call *(r2 + 4) -- method address
</code></pre>
<p>这里我们假定 correction 偏离 vatble 四个字节，get_stored_name 地址就在这里，table 的第一个标准 slot。我们还假定 this 应该通过寄存器 r3 传递，而且没有其他参数。在一个典型的现代机器上，这个代码是 two instructions( a load and a subtraction)。比单继承的所需的代码更长。</p>
<h3 id="1052-扩展"><a class="header" href="#1052-扩展">10.5.2 扩展</a></h3>
<p>上面对于接口的描述反映了 Java 的历史版本，并且省略了一点：除抽象方法外，接口还可以定义 static final field。因为这种 filed 不会再改变，所以没有引入运行时的复杂性和开销-- 编译器可以高效决定它们被使用的方式。</p>
<p>从 Java 8 开始，接口允许 static 和 default 方法，都可以有实现。 static 方法，就像 static final field，没有引入实现的复杂性：不需要访问对象 field，所以视角没有异义（没有 this 参数）。default 方法有点 tricky，这些代码期望在任何对象中被使用，而且不被重载。这个特定对于库作者非常方便：允许新方法加入到已经存在的库接口，而不会影响已经存在的用户代码，否则必须更新才能在接口继承的类中实现新方法。</p>
<p>例如，假定我们要做一个试图将已经存在的代码适配到多种语言和文化的本地化项目。我们希望加入一个新方法</p>
<pre><code class="language-java">default String get_local_name() {
  return backup_translation(get_stored_name());
}
</code></pre>
<p>到 storable_object 接口中。提供一个 storable_object 的引用，更新后的用户代码就可以调用新方法了。如果更新后的代码提供了自己的 get_local_name 就调用自己的逻辑，但是如果没有提供，实现了 storable_object 接口的类就会回落到 default 实现。为了使用 default 实现，每个继承了 storable_object 的类需要重新编译，但是用户代码可以保持不变。</p>
<p>因为 default 方法定义在接口声明中，所以只能使用接口的方法和 static field。与此同时，这个方法有又要访问具体实现类的接口方法。在我们的 storable_object 例子中，default 的 get_local_name 可以被发现，调用，get_stored_name 被定义在具体的类中。通常实现这种访问的方法依赖 fowarding routines：对每个继承了 storable_object 的类 C，并且需要 default 方法，编译器生成一个 static C- 特定的 forwarding routine ，它可以访问具体类的 this 参数，将 this correction 加入之后就可以进行常规调用，然后将指向 vtable 指针的指针传递给 default 方法。</p>
<p>事实证明，等效于 default 方法的机制已经被 Scala 语言提供，被称为 traits。事实上，traits 不仅提供了 default 方法，还有可变的 field。不再是通过创建不同视角来直接访问 field， Scala 编译器给每个继承了 traits 的类生成一组隐藏的访问器，类似 C# 的 properties。这些访问器方法的引用包含了特定接口的 vtable，可以被 default 方法调用。在不提供自己定义的 traits 类中，编译器创建一个新的私有 field 提供给访问器使用。</p>
<div style="break-before: page; page-break-before: always;"></div><p>如同 10.5 描述的，混合继承允许接口指定继承类必须提供的功能，以便在上下文中使用该类的对象。至关重要的是，接口在大多数情况下并不提供功能本身。即使存在默认实现也是为了在派生类中使用。</p>
<p>有时候从多个基类中继承功能也比较有用。比如，管理计算系统需要追踪每个系统用户的信息，大学给每个学生提供了一个账号。可能 student 派生类继承自 person 和 system_user 两个类。在 C++ 中我们可以这样写：</p>
<pre><code class="language-cpp">class student: public person, public system_user {...}
</code></pre>
<p>现在 student 类有 person 和 system_user 的所有字段和方法。</p>
<p>多重继承也出现在了多种语言中，包括 CLOS，OCaml，Python。很多老语言，包括 Simula，Smalltalk，Modula-3和 Oberson，只支持单继承。混合继承是一种常见的妥协。</p>
<hr />
<p>多重继承也引入了大量语法和实现上的问题，在<a href="../assets/supplementary_sectoins.pdf">这里</a>有更深入的阐述：</p>
<ul>
<li>假设有两个父类提供了同名方法，子类使用那个，如何都使用？</li>
<li>假设两个父类派生自同一个公共爷爷类，孙子类有几份爷爷类的拷贝？</li>
<li>单继承的实现取决于：父类对象的表示是派生类表的前缀，多重继承中，父类如何通过前缀表示</li>
</ul>
<hr />
<p>多重继承中公共爷爷类问题称为重复继承。重复继承存在多份称为复制继承，重复继承只有一份称为共享继承。Eiffel 默认为共享继承，C++默认为负值继承。两种语言都允许开发者在需要时获取另一个选项。</p>
<div style="break-before: page; page-break-before: always;"></div><p>本章开始，我们描述了面向对象编程的三个主要概念：封装，继承，动态方法绑定（多钛）。封装允许实现细节隐藏在简单接口之后。继承允许新的抽象定义在已有抽象之上，自动复用已有抽象。动态方法绑定允许在老的抽象上下文中使用新抽象的新行为。</p>
<p>不同的编程语言在不同程度上支持这些基本概念。特别的是，不同语言在要求开发者以面向对象风格编写程序上有所不同。有些作者认为真正的面向对象语言使得写非面向对象的程序非常困难。从纯粹的角度看，一门面向对象语言应该呈现一个统一计算对象模型，数据类型都是类，每个 variable 都是对象的引用，每个 subroutine 都是对象方法。而且，应该从拟人术语来思考对象：作为所有计算活动的实体。</p>
<p>Smalltalk 和 Ruby 比较贴近这种思想。事实上，如后续所述（主要内容在<a href="../assets/supplementary_sections.pdf">扩充内容</a>），即使流程控制机制，比如选择，迭代在 Smalltalk 中也是方法调用建模。另一方面，Ada 95 和 Fortran 2003 可能是冯诺依曼语言的最佳描述，并且允许开发者以面向对象风格编程。</p>
<p>所以，C++ 如何？它有非常丰富的特性，有些（多重继承，访问控制，严格初始化顺序，析构，模板）在面向对象编程中很有用，但是 Smalltalk 中没有。同时，它也有很多小问题。它的简单类型不是类。可以在类外存在 subroutine。使用 static 方法绑定以及多重继承中的重复问题。不检查的C风格的类型转换给类型检查和访问控制留下了问题。缺少垃圾收集是创建正确，自包含抽象的障碍。可能大多数是由于 C++ 要保留与 C 的兼容，允许开发者不使用面向对象模型。有人建议 C++程序员不要先学 C：他们不希望在新语言中写C风格的程序。总而言之，可以肯定地说 C++ 是一门面向对象语言，就像说 Common Lisp 是一门函数式语言一样。除垃圾收集外，C++ 提供了所有必要的工具，但是开发者确实需要“正确“使用才行。</p>
<h3 id="1071-smalltalk-对象模型"><a class="header" href="#1071-smalltalk-对象模型">10.7.1 Smalltalk 对象模型</a></h3>
<p>从历史上看，Smalltalk 是规范的面向对象语言。该语言的原始版本是 Alan kay 在 1960 年代后期在犹他大学攻读博士时设计的。随后被施乐 PARC 的软件概念小组采用，并在 1970 年代经历了五次重要修订。最终形成了 Smalltalk-80 语言。</p>
<p><a href="../assets/supplementary_sections.pdf">扩充内容</a> 可以参考到更多内容</p>
<div style="break-before: page; page-break-before: always;"></div><p>正如我们在第一章中指出，传统上，编程语言是不完美分为了命令家族和生命家族的。是时候聊聊第一部分和第二部分提到的每个家族的重要问题了。此外我们涵盖的主题还包括，句法，语义，命名，类型，抽象。前面我们太多集中于主流命令语言上，第三部分让我们偏离一下。</p>
<p>函数式和逻辑型语言是一个非主流选择。我们在第11章和12章讨论。在每种情况，我们围绕代表性语言进行讨论：Scheme OCaml 是典型的函数式语言，Prolog 是典型的逻辑型语言。在第11章我们好涉及到提前还是懒惰计算，以及函数作为第一公民，高阶函数。在12章我们涉及使全自动化通用逻辑编写困难的问题，并描述了实际使用中模型的限制。两章中可选部分都需要数学基础：Lambda Calculus for functional language, Predicate Calculus for logic programming.</p>
<p>剩下的两章讨论并发和脚本模型，这两个模型正变得越来越流行，并且是跨范式的。并发是由网络计算机的硬件并行以及多线程处理器和片上多核心驱动的。脚本是由万维网的增长以及开发者对开发效率（开发效率比运行效率更重要）的重视驱动的。</p>
<p>第13章包括通信，同步，线程创建语法，线程实现。还分开讨论了内存共享模型，线程可以显式或者隐式通过管理同一个值来同步，以及消息通信模型，线程只能通过消息进行同步。</p>
<p>第14章前半度调查了脚本语言中重要的角色的问题们：shell 语言，文本处理，报告生成，统计，程序的“粘合”，复杂程序的扩展，web 客户端服务端脚本。后半部分讨论一些更重要的脚本语言创新：flexible scoping，nameing conventions, string and pattern manipulation(extended regular expressions) and high level data types.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>最后，简短的来看看实现问题。</p>
<p>第15章讨论了语义分析后必须完成的工作，生成可执行程序。前半部分用一般术语描述了典型编译器的后端，调查了中间表示，使用第4章的属性语法描述编译器如何产生汇编代码。后半部分描述了典型过程地址空间，解释了汇编程序和链接器如何将汇编代码转换输出为可执行代码。</p>
<p>任何非平凡的语言实现，编译器都假设存在大量用于存储管理，异常处理，动态链接等预先存在的代码。更复杂的语言可能还需要事件，线程，消息等。当实现这些功能的库取决于编译器知识或者运行程序的结构时，它们被称为运行时系统。我们在16章讨论这个系统。尤其我们集中在虚拟机上，机器代码的运行时操作和反射机制，反射可以允许程序推理运行时结构和类型。</p>
<p>第15章中描述的编译器后端必不可少。本书希望呈现更完整的内容，其中大部分集中于代码提升和优化技术以生成更高效的代码。所以第17章（加上网站内容）完整涵盖了这些内容，提供了代码提升的概述。因为大多数开发者不会写编译器后端，第17章的目标更多的是传达编译器做了什么，而不是具体做法。理解这些的开发者可以更好的与编译器合作，知道什么可能发生，如何避免编写难以优化的代码。主题包括 local 和 global 的冗余消除，数据流分析，循环优化，以及寄存器分配。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>高级编程语言的每个非平凡实现通过库进行扩展。有些库的 routinues 很简单：复制内存内容，执行不被硬件支持的算术计算。有些更加复杂，比如，堆管理 routines，用于缓冲或者图形 I/O 的库需要管理大量的内部状态。</p>
<p>通常来说，我们使用术语 runtime-system，有时候只使用 runtime，来表示语言实现依赖的库集。有些 runtime 的部分，比如堆管理，建立所有 subroutine 参数的信息，可以被轻松替换。但是其他部分要求对 compiler 或者生成程序有很好的了解。简单情况下，这些知识只是一组 compiler 和 runtime 需要共同遵循的惯例（比如，subroutine 调用顺序）。更复杂的是，compiler 生成程序的 metadata，runtime 必须根据这些来完成自己的工作。比如，跟踪垃圾收集（8.5.3），以来 metadata 来识别程序中的 root pointer（所有全局，静态，和栈指针以及变量引用），以及每个引用的类型和每个分配块。</p>
<p>在前几章已经讨论了 compiler/runtime 集成的例子；我们在 16.1 中回顾一下。列表的长度和复杂性通常意味着 compiler 和 runtime 必须共同开发。</p>
<p>有些语言（显然比如 C）有非常小的 runtime 系统：执行源代码所需的大多数用户级别代码要么由 compiler 直接生成，要么包含在语言独立的库中。有些严重依赖 runtime 系统的语言，比如 C# 依赖 Common Language Infrasturcture(CLI) 标准定义的运行时。</p>
<p>就像所有的 runtime 系统，CLI 依赖 compiler 生成的数据（类型描述，异常处理列表，符号表等）。存在大量的关于 compiler 生成代码的假设（例如，参数传递的约定，同步机制和运行时栈）。但是 compiler 和 runtime 耦合程度还要深： CLI 编程接口非常复杂，以至于完全隐藏了硬件。这种 runtime 被称为 virtual machine。有些虚拟机--比如知名的 JVM--是特定语言的。有些，包括 CLI 显然是为了多种语言发明的。结合 CLI 版本的开发，微软引入了术语 managed code 表示运行在虚拟机上的代码。</p>
<p>虚拟机是使用 compile 技术对 runtime 惯例和操作程序发展趋势的一部分，也是本章的主题。我们在 16.1 中更详细的阐述虚拟机。为了避免模拟非本地指令集的开销，很多虚拟机使用 just in time(JIT) compiler 来将它们的指令集转换为硬件指令集。有些甚至在唤起 compiler 在程序运行起来之后，compile 新发现的 component 或者根据程序的动态发现属性作为输入来优化代码。使用相关技术，有些语言的实现执行二进制翻译将一种机器语言翻译为另一种机器语言【译者注：roseta2 mac translate intel -&gt; m1】，或者二进制重写来优化程序的执行。我们在 16.2 讨论这些形式的机器码 late binding。最后在 16.3 我们讨论 runtime 机制检查和修改运行程序的状态。这些机制被 debugger 或者性能探测分析工具需要。它们可能还支持反射，反射允许程序在运行时检查和推断自己的状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h2>
<blockquote>
<p>语言实现角度很多 runtime 系统有意思的话题已经在之前的章节提到了，为了开展虚拟机的阐述，这里回顾一下</p>
<ul>
<li>垃圾收集（8.3）。章节介绍所述，跟踪垃圾收集器必须发现程序中所有的根结点，确定引用的类型以及每个分配块。compacting 收集器必须能够修改程序的指针。generatinoal 收集器必须可以访问引用的主程序通过写屏障建立的新老指针。像 Java 的收集器必须可以正确的调用 finalize 方法。在支持并发或者增量的收集器实现中，主处理程序和收集器必须就某种锁定协议达成共识，以保持堆的一致性。</li>
<li>参数变量的数量（9.3.3）。有些语言允许开发人员声明不定数量的参数。在 C 中，<code>va_arg(my_args, arg_type)</code> 的调用必须返回列表 <code>my_args</code> 中的下一项。为了找到下一项，<code>va_arg</code> 必须知道哪个参数被传递到了哪个寄存器，哪个参数被传递到了栈上（以及对齐，padding和offset信息）。如果<code>va_arg</code>的代码是内嵌生成的，compiler 必须知道所有信息。如果代码在库 routines 中，routines 必须是 compiler-specific，因此需要一个小型 runtime 系统。</li>
<li>异常处理（9.4）。异常传导要求我们 unwind 栈当控制流要脱离当前 subroutine。compiler 可以通过逐帧展开当前栈。另外，一个通用的用来展开栈信息的 rontine 通常也是 runtime 系统提供。同样的，可以通过 compiler 生成的代码来找到该程序中给定点最接近的异常处理，或者通过通用的 runtime 检查程序编译时生成的 pc 处理表。后一种方法可以避免 runtime 进入离开受保护区开销（try block）</li>
<li>事件处理（9.6）。事件通常在单线程程序调用 subroutine，或者在并发程序中单独线程的 callback。依赖实现策略，它们可能要利用 compiler 调用 subroutine 的约定。也需要在主程序和事件处理之间进行同步，来保护共享数据结构的一致性。一个真正的异步调用--可能发生在主程序的任何时间的任何地方--可能需要保存整个寄存器的状态。只能发生在“安全点”的调用只需要存储很少的状态。不管哪种情况，对于不在词法嵌套最外层的 handler 的调用需要解释成为了闭包来建立正确的执行环境。</li>
<li>coroutine 和线程实现（9.5 和 13.2.4）。创建协程或者线程的代码必须分配并初始化栈，建立执行环境，执行处理未来异常所需的设置，并调用制定的 routine。像是 transfer, yield, reschedule, sleep_on （以及任何基于调度程序的同步机制）这些 routine也必须同样知道并发实现的大量细节。</li>
<li>远程过程调用（C-13.5.4）。远程过程调用（RPC）合并了事件和线程的概念：从服务器的角度，一次 RPC 是由单独线程响应客户端发起的一个事件。无论内建到语言中或者由 compiler stub，都需要知道调用约定，并发，和存储管理的 runtime 系统（分发）。</li>
<li>事务内存（13.4.4）。实现事务内存的软件必须缓存更新和读取，判断是否与其他事务存在冲突，并在执行任何可能造成不一致的操作前确认内存状态。还必须可以回滚一次事务的更新操作，或者提交完整事务。这些操作通常需要在事务开始和结束调用库，然后在中间执行读写操作。除此之外，这些调用还需要理解内存的对象形式，对象和事务的 metadata，以及事务冲突的仲裁策略。</li>
<li>动态链接（C-15.7）。任何分离编译的系统，compiler 生成 linker 需要的符号表信息用来找到外部引用。在全动态链接系统中国呢，外部引用会暂时在 linker 中以指针方式存在，必须有一个 runtime 系统。当程序试图调用一个没有链接的 routine 时，会唤起 linker，动态找到引用。具体而言，linker 查找符号表，然后以该语言约定的方式发起调用。</li>
</ul>
</blockquote>
<p>TL;</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="inspectionintrospection"><a class="header" href="#inspectionintrospection">Inspection/Introspection</a></h2>
<p>符号表对很多实用工具很有用--JIT 和动态 compiler，optimizers, debuggers, profilers, binary rewriters -- 检查程序，推理它的结构和类型。我们在 16.3.1 和 16.3.2 讨论 debugger 和 profiler。没有理由 metadata 只在外部工具中使用，实际上，Lisp 一直支持程序推理自己的内部结构和类型（有时候这种技术称为 introspection）。Java 和 C# 提供了类似的 <em>反射</em> API，允许程序利用自己的 metadata。反射同样出现在包括 Prolog 在内的多种语言和所有主要的脚本语言中。在比如 Lisp 这种动态类型语言中，反射至关重要：允许库或者应用函数检查自己的参数。静态类型语言中，反射通过一些编程方式来支持而不是自身的特性。</p>
<h3 id="1631-反射"><a class="header" href="#1631-反射">16.3.1 反射</a></h3>
<p>最普通的，反射可以用来打印诊断信息。假定我们在调试 Java 中的 queue，我们想要跟踪对象。在 dequeue 方法中，在返回前打印一下：</p>
<pre><code class="language-java">System.out.println(&quot;Dequeued a &quot; + rtn.getClass().getName());
</code></pre>
<p>如果 dequeued 的对象是一个固定长度的整数，我们会看到</p>
<pre><code class="language-shell">Dequeued a java.lang.Integer
</code></pre>
<p>更重要的是，反射在操作其他程序中很有用。比如，大多数程序的开发环境需要组织展示类，方法，和程序的变量。在具有反射的语言中，这些工具不需要检测源码：如果将已经编译的程序加载，可以使用反射 API 来查询编译器创建的符号表信息。解释器，debugger，profiler 以类似方式工作。在分布式系统中，程序使用反射来创建通用的序列化机制，能够将几乎任何结构转换成可以通过网络传输的字节流然后在另一端重构。（Java 和 C# 都在标准库中包含这样的能力，在基本语言之上实现）。在网络应用不断增长的世界，设置可以创建约定使得程序可以查询新发现的对象和其实现的方法，然后选择来调用。</p>
<p>当然，反射也很危险。</p>
<h3 id="1632-symbolic-debugging"><a class="header" href="#1632-symbolic-debugging">16.3.2 Symbolic Debugging</a></h3>
<p>大多数程序员熟悉 debugger：内建在编程语言解释器，虚拟机和集成开发环境中。也可以是单独的工具，比如广为人知的 GDB。<em>symbolic</em> 是指 degger 对于高层语言 syntax 的理解--原始程序中的 symbol。早期的 debugger 只能理解汇编。</p>
<p>典型的 debug session中，用户开启一个 debugger 控制的程序，或者 attach debugger 到正在运行的程序中。debugger 允许用户执行两种主要操作。一种是查看或者修改程序数据，另一种是控制程序的执行：开始，停止，单步执行，建立停止点和观察点。停止点是运行到指定源代码位置就停止。观察点是如果一个指定变量被读到或被写程序就停止。停止点和观察点都可以有条件，只有当特定谓词被满足才会停止。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在第15章中，我们讨论了代码生成，编译器后端的汇编，目标代码的联接。这些技术导致了正确但是没有最佳优化的代码：有很多冗余计算，寄存器，计算单元，现代微处理器缓存不高效的使用。本章介绍代码提升：专门用来生成良好（快速）代码的汇编阶段。如同 1.6.4 所述，代码提升通常被称为 optimization（优化），尽管很少存在绝对意义上的优化。</p>
<p>我们的研究将考虑简单的 peephole 优化，该优化在很小的指令窗口内“清理”生成的目标代码；local 优化，该优化为单独的代码块生成近乎最佳优化的代码；global 优化，该优化在整个 subroutine 级别进行激进的代码优化。我们不涉及进程间优化；感性起的读者可以参考本书的参考。此外，即使我们涉及的话题，我们更倾向于使得代码提升过程清晰而不是探讨其中的细节。大部分讨论将围绕单个 subroutine 的连续改进。这个扩展的示例允许我们说明几种关键形式的代码改进方法并且不会陷入到具体的细节中。</p>
<hr />
<p>更详细的请看<a href="../assets/chapter_17.pdf">chapter17</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
