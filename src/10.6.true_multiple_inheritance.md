如同 10.5 描述的，混合继承允许接口指定继承类必须提供的功能，以便在上下文中使用该类的对象。至关重要的是，接口在大多数情况下并不提供功能本身。即使存在默认实现也是为了在派生类中使用。

有时候从多个基类中继承功能也比较有用。比如，管理计算系统需要追踪每个系统用户的信息，大学给每个学生提供了一个账号。可能 student 派生类继承自 person 和 system_user 两个类。在 C++ 中我们可以这样写：

```cpp
class student: public person, public system_user {...}
```

现在 student 类有 person 和 system_user 的所有字段和方法。

多重继承也出现在了多种语言中，包括 CLOS，OCaml，Python。很多老语言，包括 Simula，Smalltalk，Modula-3和 Oberson，只支持单继承。混合继承是一种常见的妥协。

----

多重继承也引入了大量语法和实现上的问题，在[这里](../assets/supplementary_sectoins.pdf)有更深入的阐述：

- 假设有两个父类提供了同名方法，子类使用那个，如何都使用？
- 假设两个父类派生自同一个公共爷爷类，孙子类有几份爷爷类的拷贝？
- 单继承的实现取决于：父类对象的表示是派生类表的前缀，多重继承中，父类如何通过前缀表示

----

多重继承中公共爷爷类问题称为重复继承。重复继承存在多份称为复制继承，重复继承只有一份称为共享继承。Eiffel 默认为共享继承，C++默认为负值继承。两种语言都允许开发者在需要时获取另一个选项。