最后，简短的来看看实现问题。

第15章讨论了语义分析后必须完成的工作，生成可执行程序。前半部分用一般术语描述了典型编译器的后端，调查了中间表示，使用第4章的属性语法描述编译器如何产生汇编代码。后半部分描述了典型过程地址空间，解释了汇编程序和链接器如何将汇编代码转换输出为可执行代码。

任何非平凡的语言实现，编译器都假设存在大量用于存储管理，异常处理，动态链接等预先存在的代码。更复杂的语言可能还需要事件，线程，消息等。当实现这些功能的库取决于编译器知识或者运行程序的结构时，它们被称为运行时系统。我们在16章讨论这个系统。尤其我们集中在虚拟机上，机器代码的运行时操作和反射机制，反射可以允许程序推理运行时结构和类型。

第15章中描述的编译器后端必不可少。本书希望呈现更完整的内容，其中大部分集中于代码提升和优化技术以生成更高效的代码。所以第17章（加上网站内容）完整涵盖了这些内容，提供了代码提升的概述。因为大多数开发者不会写编译器后端，第17章的目标更多的是传达编译器做了什么，而不是具体做法。理解这些的开发者可以更好的与编译器合作，知道什么可能发生，如何避免编写难以优化的代码。主题包括 local 和 global 的冗余消除，数据流分析，循环优化，以及寄存器分配。